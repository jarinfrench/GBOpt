# Copyright 2025, Battelle Energy Alliance, LLC, ALL RIGHTS RESERVED

import numpy as np
from GBOpt import GBMaker, GBManipulator
import math
import uuid
from time import time
import sys
import shutil


class Mutator:
    """
    Mutator class for performing random manipulations on the passed manipulator.
    :param choices: A list of strings corresponding to GBManipulator operations.
    :param manipulator: A GBManipulator instance for mapping the choices list to GBmethod calls.
    """
    # TODO: Add more manipulator options to this class as we make more manipulators faster.

    def __init__(self, choices: list, manipulator: GBManipulator):
        self.choices = {method: getattr(manipulator, method)
                        for method in choices if hasattr(manipulator, method)}
        self.choices_keys = list(self.choices.keys())

    def mutate(self, local_random: np.random.default_rng, GB: GBMaker, manipulator: GBManipulator):
        """Performs a random mutation from the choices.
        :param local_random: A numpy.random.default_rng object for generating the random choices.
        "param GB: GBMaker object to get GB parameters for the mutation.
        :param GBManipulator: GBManipulator object to perform the mutation on.
        :return: Atom positions after the mutation."""
        choice_key = local_random.choice(self.choices_keys)
        match choice_key:
            case "insert_atoms":
                new_system = manipulator.insert_atoms(
                    method="grid", num_to_insert=1)

            case "remove_atoms":
                new_system = manipulator.remove_atoms(num_to_remove=1)

            case "translate_right_grain":
                dz = (GB.z_dim / GB.repeat_factor[1]
                      ) * local_random.uniform(0, 1)
                dy = (GB.z_dim / GB.repeat_factor[0]
                      ) * local_random.uniform(0, 1)
                new_system = manipulator.translate_right_grain(dy=dy, dz=dz)
        return new_system


class MonteCarloMinimizer:
    """
    Minimizer class for finding the lowest energy configuration of a grain boundary.
    Runs a Monte-Carlo minimization approach on the provided GBMaker object, applying the provided manipulator options stochastically.
    :param GB: GBMaker object to perform minimization on.
    :param gb_energy_func: A function that returns the energy of test GB structure. Currently expects a function
    that can be called with the params (GBMaker,GBManipulator,atom_positions,unique_id) .
    :param choices: A list of strings corresponding to GBManipulator operations. Used in setting up the Mutator class.
    :param seed: The seed to initialize the numpy.random.default_rng with.
    """

    def __init__(self, GB: GBMaker, gb_energy_func: callable, choices: list, seed=time()):
        self.GB = GB
        self.gb_energy_func = gb_energy_func
        self.manipulator = GBManipulator(self.GB)
        self.mutator = Mutator(choices, self.manipulator)
        self.accepted_idx = [0]  # Initial guess is accepted by definition
        self.__operation_list__ = ["START"]
        self.local_random = np.random.default_rng(seed)
        self.manipulator.rng = self.local_random
        self.GBE_vals = []

    def run_MC(self, E_accept: float = 1e-1, max_steps: int = 50, E_tol: float = 1e-4, max_rejections: int = 20, cooldown_rate: float = 1.0, unique_id: int = uuid.uuid4()) -> float:
        # TODO: Add options for changing from linear to logarithmic cooldown
        """
        Runs an MC loop on the grain boundary structure till the set convergence criteria are met.
        The convergence criteria parameters are optional.
        :param E_accept: Energy increase value that should have a 50% chance of being accepted during the MC iterations (default value is in J/m^2).
        :param max_steps: Sets the maximum number of iterations of MC that are run.
        :param E_tol: Grain boundary energy decrease cut-off for terminating MC iterations (default value is in J/m^2).
        :param max_rejections: Maximum number of consequtive rejections before the MC iterations are terminated.
        :param cooldown_rate: Factor ((0,1]) by which to reduce the 'temperature' of the MC simulation each iteration.
        :param unique_id: Unique unsigned integer to which to label all files generated by the MC run.
        :return: Minimized energy value.
        """

        assert cooldown_rate > 0.0 and cooldown_rate <= 1.0

        # Get initial energy
        init_gbe, _ = self.gb_energy_func(
            self.GB,
            self.manipulator,
            self.manipulator.parents[0].whole_system,
            "initial"+str(unique_id),
        )
        # Append grain boundary energy calculation to array
        self.GBE_vals.append(init_gbe)

        # Set the Monte-Carlo temperature such that there is a 50% probability of accepting an `E_accept` amount of increase to the GBE
        T = -1 * E_accept / math.log(0.5)
        rejection_count = 0

        # Set the minimum GBE
        min_gbe = min(self.GBE_vals)

        # Run the MC iterations
        for i in range(1, max_steps + 1):
            prev_gbe = self.GBE_vals[-1]

            # Generate a random mutation on the current GB atom structure
            new_system = self.mutator.mutate(
                self.local_random, self.GB, self.manipulator)

            # Evaluate the energy of this new structure and append it to the GBE values list
            new_gbe, dump_file_name = self.gb_energy_func(
                self.GB,
                self.manipulator,
                new_system,
                str(unique_id),
            )
            self.GBE_vals.append(new_gbe)

            # Accept this new structure if the energy decreases from the previous MC iteration OR probabilistically based on the energy increase
            accepted = new_gbe <= prev_gbe or self.local_random.uniform(
                0, 1) <= math.exp(-(new_gbe - prev_gbe) / T)

            if accepted:
                # Generate a new GB manipulator using the new structure from the dump file
                self.manipulator = GBManipulator(
                    dump_file_name,
                    unit_cell=self.GB.unit_cell,
                    gb_thickness=self.GB.gb_thickness,
                )
                self.manipulator.rng = self.local_random
                prev_gbe = new_gbe

                # Add the MC iteration index to the list of accepted values indices
                self.accepted_idx.append(i)
                # Set the consecutive rejection counter to zero
                rejection_count = 0

                # If new structure has the lowest energy observed so far, update the minimum GBE value and copy the dump file for this structure
                if new_gbe <= min_gbe:
                    shutil.copyfile(dump_file_name, "min" + dump_file_name)
                    del_E = abs(min_gbe - new_gbe)
                    # If the reduction in minimum energy was less than the tolerance threshold, we consider the MC solve converged
                    if del_E <= E_tol:
                        print("Meets energy tolerance criterion!")
                        break
                    min_gbe = new_gbe
            else:
                rejection_count += 1
                # If too many structures are rejected back-to-back, we prematurely stop the MC iterations since we are stuck
                if rejection_count > max_rejections:
                    print("Too many rejections!")
                    break
            # The temperature is cooled down to gradually reduce the probability of accepting worse solutions over time and let the MC minimization converge
            T *= cooldown_rate

        return min_gbe
